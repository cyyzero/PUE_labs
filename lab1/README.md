这个实验是通过符号表和模拟的内存模仿C变量的声明和赋值等操作。由于不会编译原理，很多地方都是瞎写的 （

大概思路如下：

以这个复杂声明为例：

```C
double (* (* (*fp) ()) [10]) ()
```

这里fp是一个指针，指向一个函数，函数参数为空，返回值为一个指针，指向一个大小为10的数组，数组的元素为指针，指向函数，函数参数为空，返回值为double。


C++中有个`typeid`操作符，能实现静态或者多态的类型鉴别。比如说

```C
double (* (* (*fp) ()) [10]);
std::cout << typeid(fp).name();
```

g++的输出结果是`PFPA10_PdvE`。

- `P`代表指针，后面代表指向的类型；
- `F`和`E`代表函数，`F`和`E`之间的就代表返回值和参数，返回值在前参数在后。
- `A`代表数组，紧接着的数字代表元素的数目，再接着是个下划线`_`，下划线后再是元素的类型；
- 基本类型也只保留一个字符（通常是类型的首字符，比如这里的`d`）。

这就启发了我，C中变量的不同类型可以通过类似的样式来映射成不同的字符串。

由于g++的这套`mangling`方法为了效率牺牲了可读性，所以我采用的表示类型的样式是：

- `*”代表指针，后面代表指向的类型;
- `Func`代表函数，后面跟一对括号`()`，括号中间是参数类型，接着是`->`，再接着就是返回值的类型；
- `Array`代表数组，紧接着的数字代表元素的数目，再接着是个下划线`_`，下划线后再是元素的类型；
- 基本类型保持不变；

所以`double (* (* (*fp) ()) [10])`的类型我将它表示成`*Func()->*Array10_*double`；

使用变量的时候，就是生成类型字符串的逆过程。比如说已知fp的类型为`*Func()->*Array10_*double`，则`*fp`的类型就是fp指向的类型，就是`Func()->*Array10_*double`。